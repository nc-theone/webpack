
> webpack打包优化，貌似已经被人研究了很久，这里主要说一下自己的看法

- 个人认为，webpack打包优化可以区分为两个维度，速度和体积；前者主要缩短打包的时间，后者主要降低包的体积；给出一张图，总结的影响速度和体积的几个方面

### 速度

- 环境区分
  - 在配置webpack的时候，一般会区分`dev`以及`prod`环境，在`dev`下，一般是不压缩代码的；这样在文件变更的时候，降低了压缩时间，提高了打包速度

- 插件、工具
  - 其实打包优化的首要选择，就应该从相应的`loader`以及`plugins`入手；比如并行处理预编译，并行处理文件压缩
  - 这里要推荐一下`happypack`以及`webpack-uglify-parallel`，具体的使用方式可以自行查找

- 打包文件引入
  - 全量打包的好处很明显，就是不会担心遗漏掉某些变更，但是随着工程体积逐渐增加，全量打包势必降低打包速度；如何减少`webpack.config.js`中的`entry`，是需要考虑的一个问题；你的工程里面也许会有一些公用的组件或者方法，如何做到公用组件或者方法变动之后，精准的识别到需要打包的文件，也是一个需要考虑的问题；有得有失，看具体的工程对打包速度的需要了
  - 依赖包引用方式：编译好的js/css，未经预处理的源码jsx/less/scss；引入未经处理的文件会命中webpack配置中的loader，造成进一步的预处理，进而降低打包速度，在引用的时候 需要额外注意

### 体积

- 环境区分
  - 在笔者的开发过程中，就曾遇到，有些代码是仅仅在`dev`阶段遇到的，那么在`prod`环境就无需引入，这种情况可以在源码中使用`process.env`进行区分

- 三方包引入
  - 对于日期处理或者数组的处理，相信我们的首选会是类似于`moment`或者`lodash`这种比较成熟的组件库，但是这种组件库的引入方式基本会导致全部api被打包进入业务代码，如何只打包我们需要的api：
    - 一种方式是，在引用的时候，直接引用较深层次的文件，比如

    ```js
    // 直接引用fp目录下的add方法
    import _add from 'lodash/fp/add';
    ```

    - 但是你会发现，这样的引入方式需要查看lodash的api组织结构，略显麻烦；可以推荐你一个babel插件[babel-plugin-lodash](https://github.com/lodash/babel-plugin-lodash)
    
    - 第二种方式，就是寻找替代方案；可以将部分功能，自己用代码实现，或者寻找更加轻量级的模块

- 代码编写规范
  - 这一条和`webpack 2.0`的新特性`tree-shaking`有关，详细可以参考[tree-shaking 小总结](./tree-shaking.md)

### webpack.config.js

- 可以查看本仓库根目录下的[webpack.config.js](../webpack.config.js)
